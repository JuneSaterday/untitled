redis分布式锁

1.单机
使用 SET 命令和 Lua 脚本在 Redis 单节点上实现分布式锁

SETNX lock_key 1

DO 业务逻辑

DEL lock_key

两个风险：
1.在DO 业务逻辑时，发生异常，一直没有DEL lock_key;
针对这种情况，给lock_key设置过期时间。

2.客户端A加锁后，假如客户端B执行了DEL释放锁，A的锁被误释放。如果C正好也申请加锁,则成功锁定。
A,C同时操作共享数据，数据会被修改错误

为了应对这个问题，我们需要能区分来自不同客户端的锁操作。
在使用 SETNX 命令进行加锁的方法中，我们通过把锁变量值设置为 1 或 0，表示是否加锁
成功。1 和 0 只有两种状态，无法表示究竟是哪个客户端进行的锁操作。所以，我们在加
锁操作时，可以让每个客户端给锁变量设置一个唯一值，这里的唯一值就可以用来标识当
前操作的客户端。在释放锁操作时，客户端需要判断，当前锁变量的值是否和自己的唯一
标识相等，只有在相等的情况下，才能释放锁。这样一来，就不会出现误释放锁的问题
了。

// 加锁, unique_value作为客户端唯一性的标识
SET lock_key unique_value NX PX 10000

/释放锁 比较unique_value是否相等，避免误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
return redis.call("del",KEYS[1])
else
return 0
end

这是使用 Lua 脚本（unlock.script）实现的释放锁操作的伪代码，其中，KEYS[1]表示
lock_key，ARGV[1]是当前客户端的唯一标识，这两个值都是我们在执行 Lua 脚本时作为
参数传入的。

redis-cli --eval unlock.script lock_key , unique_value


缺点：

我们现在只用了一个 Redis 实例来保存锁变量，如果这个 Redis 实例发生故障宕机
了，那么锁变量就没有了。此时，客户端也无法进行锁操作了，这就会影响到业务的正常
执行。所以，我们在实现分布式锁时，还需要保证锁的可靠性。那怎么提高呢？这就要提
到基于多个 Redis 节点实现分布式锁的方式了。


2.基于多个 Redis 节点实现分布式锁

Redlock 算法实现高可靠分布式锁

Redlock 算法的实现需要有 N 个独立的 Redis实例

第一步是，客户端获取当前时间。
第二步是，客户端按顺序依次向 N 个 Redis 实例执行加锁操作。
第三步是，一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过
程的总耗时

客户端只有在满足下面的这两个条件时，才能认为是加锁成功。
条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；
条件二：客户端获取锁的总耗时没有超过锁的有效时间。